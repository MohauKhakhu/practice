# -*- coding: utf-8 -*-
"""Session 3 data manipulation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YI_kkp0quXs0Ey3kYLFIa_TI_cRwpp0n
"""

import pandas as pd

df=pd.read_csv('/content/sample_data/california_housing_train.csv')

print(df.head())

print(df.info())



"""filtering"""

filtered_df=df[df['housing_median_age']>25]

"""sort

"""

Sorted_df= filtered_df.sort_values(by='housing_median_age')

print(Sorted_df)

"""grouping and aggregationg"""

grouped= df.groupby('housing_median_age')
result=grouped['median_house_value'].mean()
print(result)

df.head()

df['longitude']

df['longitude', 'latitude']

df.loc[2]

df.iloc[0]



"""filtering-"""





df.rename(columns={'housing_median_age': 'age'}, inplace=True)
df.head()

"""Data inspections"""

df.head()

"""# New Section"""

df.describe()







df.isnull()

df.info()

"""unuveriete analysis"""

import matplotlib.pyplot as plt

df['population'].hist()
plt.xlabel('population')
plt.ylabel('count')
plt.title('histogram')

import seaborn as sns

sns.boxenplot(x=df['population'])
plt.title('boxplot')

plt.scatter(df['population'], df['median_house_value'])



"""heat map"""

correlation_matrix=df.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.show()

"""LISTS in python"""

li=['learning', "python", "is", "fun", True]
print(li)
type(li)

li=list(('learning', "python", "is", "fun", True))
print(li)
type(li)
li.append('new')
print(li)
li.remove('new')
print(li)
l2= [1,2,3,4,5]
li.extend(l2)
print(li)



l3= [1,2,3,4,5]
print(l3)
type(l3)
print(sum(l3))
print(min(l3))
print(max(l3))

range(1,10)

import numpy as np
import pandas as pd
pd.read_csv('/content/sample_data/california_housing_train.csv')

import pandas as pd
pd.read_csv('/content/sample_data/california_housing_train.csv')

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
pd.read_csv('/content/sample_data/california_housing_train.csv')

import pandas as pd
from sklearn.tree import DecisionTreeClassifier,plot_tree
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import numpy as np

df=pd.read_csv('/content/sample_data/california_housing_test.csv')
df.shape

df.head()

#dealing with missing values
print(df.isnull().sum()) #display the number of null values for each field
#check whether or not there are ANY null values in the data frame
print("dataframe has null values?", df.isnull().values.any())

#Split data into feature(x) and response (y)
x=df.drop('median_house_value', axis=1)
y=df['median_house_value']

# prompt: create a packet sniffer

!pip install scapy

import scapy.all as scapy

def sniff_packets(interface="eth0", count=10):
  """Sniffs packets on the specified interface and prints basic information.

  Args:
    interface: The network interface to sniff on (default: eth0).  You may need to change this
               to your correct network interface name (e.g., wlan0, en0).
    count: The number of packets to capture (default: 10).
  """

  try:
    packets = scapy.sniff(iface=interface, count=count, store=True)  # Capture packets
    for packet in packets:
      # Extract source and destination IP addresses
      src_ip = packet[scapy.IP].src if scapy.IP in packet else "N/A"
      dst_ip = packet[scapy.IP].dst if scapy.IP in packet else "N/A"

      # Extract source and destination ports (if TCP/UDP)
      if scapy.TCP in packet:
        src_port = packet[scapy.TCP].sport
        dst_port = packet[scapy.TCP].dport
        protocol = "TCP"
      elif scapy.UDP in packet:
        src_port = packet[scapy.UDP].sport
        dst_port = packet[scapy.UDP].dport
        protocol = "UDP"
      else:
        src_port = "N/A"
        dst_port = "N/A"
        protocol = "Other"

      print(f"Source IP: {src_ip}, Source Port: {src_port}")
      print(f"Destination IP: {dst_ip}, Destination Port: {dst_port}")
      print(f"Protocol: {protocol}")
      print("-" * 20)

  except PermissionError:
    print("Permission denied.  You may need root privileges to capture packets.")
  except OSError:
    print(f"Interface '{interface}' not found or not available.")


if __name__ == "__main__":
  # Change "wlan0" to your network interface if necessary!
  sniff_packets(interface="wlan0") # Might need to change to eth0 or your wireless interface